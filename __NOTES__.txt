
= TODOS =

- Jackalope::REST::Resource::Repository
    - this should return perl data structures to the web-service
      which should be the resource wrapper, minus the links, which
      are to be filled in by the web-service
    - &list should optionally take some parameters
        - search term(s)
        - start/end for paging of results
        - add this to the corresponding schema/web/service as well
    - Resource wrapper notes
        - the elements of the link are also the elements
          that the Router would use to construct the URLs
          so that fits together nicely
        - the version string is a SHA1 of the content, so that we can
          take advantage of ETags
            - read up on http://en.wikipedia.org/wiki/HTTP_ETag

- Jackalope::REST::Service
    - we need to write defaults into the route so that they
      can be idenfified from the outside and URIs can be created
        - the method and rel should do enough
    - it can make some assumptions about the repository
      knowing that it is going to use the Jackalope::REST::Resource::Repository
      role, this should simplify the metadata even more
      if not eliminate the metadata completely
    - Remember, PUT actions are Idempotent, you should always return
      the same resource if it hasn't been changed, which means checking
      the version to be sure before we do anything
    - read about 201 Created in http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html
    - we should be checking methods too and returning 405 when we find something amis
        - 405 -> The method specified in the Request-Line is not allowed for the resource
                 identified by the Request-URI. The response MUST include an Allow header
                 containing a list of valid methods for the requested resource.
    - might want to return 412 Precondition Failed when delete If-Matches fails

- spec for REST API
    - NOTE: This is heavily inspired by the ATOM publishing protocol
    - CRUD actions
        - describedby
            - return the schema that it is created with
        - listing
            - listing is done by GETing to the URI of a collection
            - the result is basically a list of resources, nothing more
            - this should take search params and paging params as well
            - returns 200 status
        - creation
            - creation is done by POSTing to the specified creation URI
            - returns a 201 status
            - the response Location header should provide the link to read the resource
            - the newly created resource should be in the body of the response
                - the resource should include links that
                  provide hrefs for the various other actions
        - read
            - returns 200 status
            - reading is done by GETing the specified reading URI
                - the resource id should be embedded in the URI
        - update
            - returns 202 status
            - updating is done by PUTing to the specified update URI
                - the resource id should be embedded in the URI
                - you need to PUT the full wrapped resource (minus the links metadata)
                  so that we can also test the version string to make sure it is in sync
            - the updated resource is sent back in the body of the request
        - delete
            - returns 204 status
            - deletion is done by sending DELETE to the specified deletion URI
                - the id should be embedded in the URI
                - an optional If-Matches header is supported for version checking
    - Caching options
        - we should support eTags and conditional GETS, but this is more for the client end
            - see: http://www.atomenabled.org/developers/protocol/atom-protocol-spec.php#edit-no-lost-update
            - this will allow us to do two things
                1) cache more effectively
                2) detect conflicts
            - this should gel with the 'version' field in the resource spec
    - Media (binary data)
        - see: http://www.atomenabled.org/developers/protocol/atom-protocol-spec.php#media-link-entries

- Jackalope.Schema.Repository
    - refactor the compilation process
      to match the Perl version
        - the 003-web.t.js tests are broken because of this
    - ponder separating the web part of the schema afects the JS

- ponder spliting things up
    - Jackalope
    - Jackalope::Web::REST
    - Jackalope::JS
    - the reasoning being that some parts are
      more opinionated then others and it would
      be nice to give people flexibility

- think about renaming the schema URIs
  to something more sensible, like ...
    - jackalope/core/ref
    - jackalope/core/type/any, etc...
    - jackalope/core/hypermedia/hyperlink
    - jackalope/core/hypermedia/xlink
    - jackalope/web/rest/resource
    - jackalope/web/rest/service

== KNOWN ISSUES ==

- Jackalope::Schema::Respository
    - extending a self referencing schema in a properties is not allowed
      but you can do it in links, so something like this ...
          {
            id => "foo/schema",
            properties => {
                bar => { extends => { $ref => "#" } }
            }
          }
      will not work correctly because it would lead to a circular loop.
      However, this does work:
          {
            id => "foo/schema",
            properties => {
                bar => { $ref => "#" }
            }
          }
      the solution is to make another schema for 'bar' excplictly, however
      we do not properly throw an error now, which is bad.

== LOW PRIORITY ==

- Jackalope.js
    - add some kind of basic Bread-Board type thing

- Jackalope::Schema::Spec & Jackalope.Schema.Spec
    - perhaps use that description cleanup method in GenerateSpec on the actual spec

- Test::Jackalope & Test.Jackalope
    - write .toJSON methods that strip the __compiled_* stuff from the output of schemas
    - validation_fail should also take some kind of
      test to check the right error appears
        - fixtures will need to support this too

- test_fixtures
    - write more of them

- Jackalope::Schema::Validator::Core
    - make it use Moose types to check against

- Jackalope::Serializer
    - Jackalope::Serializer::XML (TODO - perigrin)
    - Jackalope::Serializer::YAML (why??)

== PERHAPS ==

- Jackalope::API::*
    - create a set of roles that can be used
      in the Bread::Board config to typemap
      to concrete classes
    - NOTE: I tried this, it didn't feel right
      but should keep the idea around just in case

== LINKS ==


http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html
http://en.wikipedia.org/wiki/Representational_State_Transfer
http://martinfowler.com/articles/richardsonMaturityModel.html
http://code.msdn.microsoft.com/cannonicalRESTEntity
http://www.w3.org/TR/xforms/
http://thisweekinrest.wordpress.com/
http://tools.ietf.org/html/rfc5988
http://alexscordellis.blogspot.com/2010/11/restful-architecture-what-should-we-put.html
http://restinpractice.com/default.aspx

- ATOM
    - http://www.atomenabled.org/

- LINK relations
    - http://www.iana.org/assignments/link-relations/link-relations.xhtml

- HTTP status codes
    - https://demo.staging.fellowshiponeapi.com/v1/Util/HttpStatusCodes.help




