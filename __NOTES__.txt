
= TODOS =

- Jackalope::ResourceRepository
    - should this be renamed Jackalope::Web::ResourceRepository??
    - this should return perl data structures to the web-service
      which should be the resource wrapper, minus the links, which
      are to be filled in by the web-service
    - &list should optionally take some parameters
        - search term(s)
        - start/end for paging of results
        - add this to the corresponding schema/web/service as well
    - Resource wrapper notes
        - how smart should I make the resource??
            - should it be a class?
            - should it know how to compare itself?
        - the elements of the link are also the elements
          that the Router would use to construct the URLs
          so that fits together nicely
        - the version string is a SHA1 of the content, so that we can
          take advantage of ETags
            - read up on http://en.wikipedia.org/wiki/HTTP_ETag
            - this means the serialization needs to
              use the canonical flag
                - using canonical JSON also means that it will be
                  easy to add digital sigs if we want too.
                - it actually doesn't slow stuff down too much, here
                  is the benchmark for encoding the entire spec
                  (585 lines of JSON) in both the canonical and
                  non-canonical, and it isnt that bad
                    |                 Rate     canonical non-canonical
                    | canonical     6270/s            --           -8%
                    | non-canonical 6817/s            9%            --

- Jackalope::Web::Error::
    - a set of Throwable exceptions for the various HTTP status codes
        - 400 Bad Request
        - 404 Not Found
        - 409 Conflict
        - 500 server error

- Jackalope::Web::Service
    - we should pass in a Factory to the Web::Service and the factory
      can choose which type of target object based on patterns
      if no pattern exists then ...
      - target_class in the link->metadata should handle names like Moose Traits and Catalyst plugins
          +Some::Full::Path => is handled straight
          Another           => becomes Jackalope::Route::Target::Another

- Jackalope::Web::Route::Target::REST::
    - we need to write defaults into the route so that they
      can be idenfified from the outside and URIs can be created
        - the method and relation should do enough
    - it can make some assumptions about the repository
      knowing that it is going to use the Jackalope::ResourceRepository
      role, this should simplify the metadata even more
      if not eliminate the metadata completely
    - Remember, PUT actions are Idempotent, you should always return
      the same resource if it hasn't been changed, which means checking
      the version to be sure before we do anything
    - read about 201 Created in http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html

- spec for REST API
    - NOTE: This is heavily inspired by the ATOM publishing protocol
    - CRUD actions
        - listing
            - listing is done by GETing to the URI of a collection
            - the result is basically a list of resources, nothing more
            - this should take search params and paging params as well
        - creation
            - creation is done by POSTing to the URI of a collection
            - returns a 201 status
            - the response Location header should provide the link to read the resource
            - the newly created resource should be in the body of the response
                - the resource should include links that
                  provide hrefs for the various other actions
        - read
            - reading is done by GETing the specified reading URI
                - the resource id should be embedded in the URI
        - update
            - updating is done by PUTing to the specified update URI
                - the resource id should be embedded in the URI
                - this URI may or may not be the same as the read URI (API designers choice)
                - you need only PUT the resource body data, which is not required to have an id
                  the associated metadata (links, etc) are considered read-only and the
                  responsibility of the server so there is no need for it to be returned
            - the updated resource is sent back in the body of the request
        - delete
            - deletion is done by sending DELETE to the specified deletion URI
                - the id should be embedded in the URI
                - this URI may or may not be the same as the read URI (API designers choice)
    - Caching options
        - we should support eTags and conditional GETS, but this is more for the client end
            - see: http://www.atomenabled.org/developers/protocol/atom-protocol-spec.php#edit-no-lost-update
            - this will allow us to do two things
                1) cache more effectively
                2) detect conflicts
            - this should gel with the 'version' field in the resource spec
    - Media (binary data)
        - see: http://www.atomenabled.org/developers/protocol/atom-protocol-spec.php#media-link-entries

- Jackalope.Schema.Repository
    - refactor the compilation process
      to match the Perl version
        - the 003-web.t.js tests are broken because of this
    - ponder separating the web part of the schema afects the JS

- ponder spliting things up
    - Jackalope
    - Jackalope::Web::REST
    - Jackalope::JS
    - the reasoning being that some parts are
      more opinionated then others and it would
      be nice to give people flexibility

- think about renaming the schema URIs
  to something more sensible, like ...
    - jackalope/core/ref
    - jackalope/core/type/any, etc...
    - jackalope/core/hypermedia/hyperlink
    - jackalope/core/hypermedia/xlink
    - jackalope/web/rest/resource
    - jackalope/web/rest/service


== LOW PRIORITY ==

- Jackalope.js
    - add some kind of basic Bread-Board type thing

- Jackalope::Schema::Spec & Jackalope.Schema.Spec
    - perhaps use that description cleanup method in GenerateSpec on the actual spec

- Test::Jackalope & Test.Jackalope
    - write .toJSON methods that strip the __compiled_* stuff from the output of schemas
    - validation_fail should also take some kind of
      test to check the right error appears
        - fixtures will need to support this too

- test_fixtures
    - write more of them

- Jackalope::Schema::Validator::Core
    - make it use Moose types to check against

- Jackalope::Serializer
    - Jackalope::Serializer::XML (TODO - perigrin)
    - Jackalope::Serializer::YAML (why??)

== PERHAPS ==

- Jackalope::API::*
    - create a set of roles that can be used
      in the Bread::Board config to typemap
      to concrete classes
    - NOTE: I tried this, it didn't feel right
      but should keep the idea around just in case

== LINKS ==


http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html
http://en.wikipedia.org/wiki/Representational_State_Transfer
http://martinfowler.com/articles/richardsonMaturityModel.html
http://code.msdn.microsoft.com/cannonicalRESTEntity
http://www.w3.org/TR/xforms/
http://thisweekinrest.wordpress.com/
http://tools.ietf.org/html/rfc5988
http://alexscordellis.blogspot.com/2010/11/restful-architecture-what-should-we-put.html
http://restinpractice.com/default.aspx

- ATOM
    - http://www.atomenabled.org/

- LINK relations
    - http://www.iana.org/assignments/link-relations/link-relations.xhtml

- HTTP status codes
    - https://demo.staging.fellowshiponeapi.com/v1/Util/HttpStatusCodes.help




